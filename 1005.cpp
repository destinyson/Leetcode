/**************************************1005 - K 次取反后最大化的数组和*************************************

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。


示例 1：

输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。

示例 2：

输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。

示例 3：

输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。


提示：

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100
*****************************************************************************************************/

//首先排序，然后将尽可能多的负数反转，从最小的负数开始

//如果还剩次数，继续遍历，如果有0，反转全部在0上做，和值最大值不会变化

//如果没有0，且剩余次数为奇数，就挑绝对值最小的数反转

//若剩余次数为偶数，和值最大值不会变化

class Solution {
public:
    int largestSumAfterKNegations(vector<int>& A, int K) {
        sort(A.begin(), A.end());
        int len = A.size();
        int sum = 0;
        for (int i = 0; i < len; i++)
            sum = sum + A[i];
        int neg = 0;
        for (int pos = 0; pos < len && K > 0; pos++)
        {
            if (A[pos] < 0)
            {
                neg = -A[pos];
                sum = sum + neg * 2;
                K--;
            }
            else if (A[pos] == 0)
                break;
            else
            {
                if (K % 2)
                {
                    int min = (neg && neg < A[pos]) ? neg : A[pos];
                    sum = sum - min * 2;
                }
                break;
            }
        }
        return sum;
    }
};
