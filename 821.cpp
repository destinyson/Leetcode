/**************************************821 - 字符的最短距离*************************************

给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。

示例 1:

输入: S = "loveleetcode", C = 'e'
输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]

说明:

字符串 S 的长度范围为 [1, 10000]。
C 是一个单字符，且保证是字符串 S 里的字符。
S 和 C 中的所有字母均为小写字母。
*****************************************************************************************************/

//首先扫描字符串S，记录S中C的出现位置

//然后根据出现位置分段，然后分段求值

class Solution {
public:
    vector<int> shortestToChar(string S, char C) {
        int len = S.length();
        vector<int> ans(len);
        vector<int> pos;
        for (int i = 0; i < len; i++)
        {
            if (S[i] == C)
            {
                ans[i] = 0;
                pos.push_back(i);
            }
        }
        int pos_len = pos.size();
        for (int i = 0; i < pos[0]; i++)
            ans[i] = pos[0] - i;
        for (int i = pos.back() + 1; i < len; i++)
            ans[i] = i - pos.back();
        for (int flag = 0; flag < pos_len - 1; flag++)
        {
            int start = pos[flag];
            int finish = pos[flag + 1];
            int middle = (start + finish) >> 1;
            for (int i = start + 1; i <= middle; i++)
                ans[i] = i - start;
            for (int i = middle + 1; i < finish; i++)
                ans[i] = finish - i;
        }
        return ans;
    }
};
